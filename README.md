<<<<<<< HEAD
```https://pythontutor.com/``` - ссылка на сайт для просмотра программы
# Visual Studio Code
```shell
Alt + T - удаление лишних пробелов
```
```shell
Ctrl + Shift + I - форматирование программы
```
```shell
Ctrl + ~ - терминал
```
# БИБЛИОТЕКИ
## #include <iomanip>
```Библиотека iomanip для слов-манипуляторов: left/right, fixed, setfill(), setw(), setprecision()```
```shell
/* left - манипулятор, который влияет на все последующие выводы,
пока не будет изменён. Манипуляторы left и right из библиотеки
iomanip работают только вместе с setw()
*/
```
## #include <cstring>
```- Для работы strlen() - функцию, которая возращает правильную длину C-style массива```
## #include <cassert>
```#include <cassert> // Для assert``` - заставляет программу аварийно завершаться при неправильной логике
## #include <random> - для рандома
```shell
random_device rd; // Генератор, источник энтропии(хаоса)
```
```shell
mt19937 gen(rd()); // Для получения случайных чисел высокого качества
```
```shell
uniform_int_distribution<> dist(3, 6); // Равномерное распределение в диапазоне чисел
```
## ```#include <cstring>``` - для строк - Для получения длины методом strlen()
```#include <limits.h>``` - содержит минимальные и максимальные значения для фундументальных типов c++ (int, float...)
## stack - библиотека стека
## cmath - Библиотека математических операций
## algorithm - Библиотека алгоритмов
    ```sort(userNums, end);``` - Сортировка массива
    ```all_of```
    ```greater<>()```
    ```int maximum = max({wordSize1, wordSize2, wordSize3});``` // Для {} - нужна библиотека algorithm
## iomanip
    ```cout << setprecision(4);``` - Определяет кол-во нулей после точки
        ```cout << ... << showpoint << ...;``` - Показать нули после запятой(работает вместе с setprecision())
        ```cout << ... << showpos << ...;``` - Показать знак(+/-)
# БИБЛИОТЕКА unistd.h
```#include <cmath>``` - Библиотека математических операций
```unistd.h``` - библиотека
```srand(time(0));``` - програмный таймер
```sleep(1)``` - задержка в 1 секунду
```system("clear");``` - очистка экрана терминала
```g++ -Wall main.cpp -o main.bin``` - способ компилирования программы без clang
# ЛОГИЧЕСКИЕ ОПЕРАЦИИ
```!= \ (not_eg)``` - логическое неравенство
```! \ (not)``` - логическое не(инверсия)
```==``` - логическое равенство
```|| \ (or)``` - логическое ИЛИ
```&& \ (and)``` - логическое И
```^ \ (xor)``` - исключающее ИЛИ
# ТЕРМИНАЛЬНЫЕ КОМАНДЫ
```g++ <назв файла> -o <назв файла.bin>``` - тот же компилятор что и clang, но его нет на Windows
```grep -iRl "SIZE"``` - нахождение файла с искомым словом в кавычках
```echo | g++ -dM -E -x c++ - | grep __cplusplus``` - проверка версии используемой версии C++
```ascii - d``` - таблица символов
```bc -l``` - калькулятор командной строки
```Ctrl + Z``` - выход из программы
```xxd -b main.bin``` - показать содержимое бинарного файла
```echo '...' | xxd -b``` - показать текст в бинарном виде
```objdump -d main.bin``` - дизассемблер бинарного файла
```file main.bin``` - информация о файле
```stat main.bin``` - статистика файла
```ldd main.bin``` - информация об использованных библиотек в донном файле
```time ./main.bin``` - возвращает время работы программы
```strace ./main.bin``` - отладочная информация
```ulimit -s``` - размер стека компьютера
```cppcheck -q --enable=all counterColor.cpp``` - поиск ошибок
```clang-format file.cpp > format.cpp``` - команда форматирующая текст и пересоздавающая её в другой файл
```ascii -b``` - таблица ascii в бинарном виде
# КОМПИЛЯЦИЯ И ЗАПУСК ПРГРАММЫ
```clang++ -Wall -std=c++17 modernMethodGetSizeArr.cpp -o main.bin``` - компиляция программы на c++17
```clang++ -Wall charDelay.cpp -o charDelay.bin``` - компиляция программы
```./main.bin``` - запуск программы
# КОМАНДЫ GIT
```git status``` - текущее состояние репозитория
```git add *``` - добавить изменения в репозиторий
```git commit -m 'Added/Update file'``` - зафиксировать изменения
```git push``` - отправить изменения на сайт git
```git pull``` - синхронизация репозиториев
```gtypist ru.typ``` - клавиатурный тренажёр кириллицы
```gtypist``` - клавиатурный тренажёр латиницы
# Unit-test
```- обрабатывает отдельные функции```
```ключевое слово - assert - утверждать```
```assert(); - при false аварийно останавливает программу```
# ФУНКЦИИ
```shell
string toUpperString(string& str) {
    for (auto& c : str) {
        c = static_cast<char>(toupper(static_cast<unsigned char>(c)));
    }
    return str;
}
```
```shell
Перегрузка функций - это определение нескольких одноимённых функций с разными параметрами
Каждая из перегруженных функций должна иметь уникальные параметры
Перегрузка функции может упростить создание программы
Перегрузка функции имеет небольшой риск определения совпадений преобразований
```
```shell
Параметр функции (формальный параметр) - это переменная,
создаваемая при объявлении функции:
void val(int x); // x - это параметр
int res(int a); // a - это параметр
Аргумент функции (фактический параметр) - это значение, которое
передаёт в функцию вызывающий объект:
val(7); // 7 - это аргумент
res(9); // 9 - это аргумент
```
```shell
Параметры по умолчанию либо все, либо справа
```
```shell
void func(int x, int y) { // x и y - параметры
    cout << x << ' ' << y << '\n';
/*
    переменные x и y создаются и уничтожаются внутри этой функции (они локальные переменные)
*/
}
```
```shell
Синтаксис функции - ТИП + ИМЯ + КОД
```
```shell
Типом ф-ции может быть ещё и имя структуры, и имя перечисления
```
# СТЕК
```shell
stack<int> newStack; // Имя стека
```
```myStack.size();``` - Размер стека
```newStack.push(5);``` - Помещаем данные в стек
```newStack.pop();``` - Удаляет верхний элемент из стека
```myStack.top()``` - Возвращает ссылку на верхний элемент стека
```shell
if (myStack.empty()) { - если стек пустой
}
```
#РЕКУРСИЯ
```shell
/*
1. Все рекурсии должны иметь условие своего завершения
2. Рекурсия позволяет осуществлять повторяющиеся инструкции без циклов
*/
```
```shell
Рекурсия - это что-то вроде сна внутри сна или зеркала в зеркале
Функции в программировании - это программы внутри программы
Функции содержат инструкции, которые выполняются во время их вызова
Функции располагаются в области оперативной памяти компьютераб называемой Стек (Stack)
В момент вызова функции ей можно передать аргумент (значение)
Функции могут возвращать значения, которые есть вывод функции
Оперативная память компьютера состоит из стека (автоматическая память), в котором покадрово
выполняются функции. Каждый вызов функции - это кадр (фрейм).
Таким образом образуется стек вызовов. Стек вызовов помнит каждый кадр.
Все кадры-вызовы обрабатываются автоматически.
Стек вызовов работает по принципу "последним вошёл - первым вышел".
Т.е. последняя вызванная функция помещается в самый верх стека.
По завершении работы функций стек автоматически очищается.
Рекурсивная функция в программирование - это функция, которая вызывает саму себя.
Все рекурсии должны содержать условие своего завершения!
Бесконечная рекурсия обязательно и быстро переполнит Стек.
Получить доступный размер Стека можно командой "ulimit -s".
В программирование почти нет ни одной задачи для рекурсии,
которую нельзя было бы выполнить обычным циклом.
Рекурсию можно использовать, например для прохождения лабиринта или
поиска файлов во вложенных каталогах.
```
# МЕТОД
```cin.get();``` - если нужно нажать Enter
```revers();```
```shell
string phrase {"Hello, World"}; // Можно по-новому через uniform-инициализации
cout << phrase << endl;
reverse(phrase.begin(), phrase.end());
cout << phrase << endl;
```
# ПОНЯТИЯ
```Итератор - элемент для перехода по массиву с какой-то целью```
```int min = INT_MAX;``` - Максимальное значение для типа int
```shell
в const auto - автоматически выделяется память (поэтому в структуру запихнуть не получится)
```
```shell
foo и boo - негласное соглашение называть программы так, если не знаешь как их назвать
```
```shell
Сравнивать два вещественных числа - сложная задача для компьютера
```
```// Литерал - это элемент программы, который представляет значение```
```shell
Парадигмы программирования:
1) Процедурное - без функций, перечислений, структур и классов
2) Структурное - с перечислениями, структурами и функциями, но без классов
3) ООП - Объектно-ориентированное программирование - структурное + классы и шаблоны
```
```Каждая функция должна выполнять только 1 задачу и делать это хорошо```
```НЕ рекомендуется ставить таймер в функцию```
# МАССИВЫ
```shell
void printArray(const string arr[], const size_t SIZE) {
    for (size_t i = 0; i < SIZE; ++i) { cout << arr[i] << ' '; }
    cout << '\n';
}
// Статически массив при передачи в функцию теряет информацию о своей длине, поэтому в ф-цию задаётся 2 переменные
```
```shell
Во многих случаях при передачи в функцию фиксированный массив распадается на указатель,
который есть 0-й элемент массива.
Фиксированный массив всегда знает свою длину.
Для хранения массива в функции или структуре используется указатель.
```
```shell
swap(str.at(start), str.at(end)); // Метод обработки с проверкой // Меняет местами 2 значения
//swap(str[start], str[end]); // Другой способ // без проверки // не желательный вариант
```
```shell
int array[5] = {0};
for (const auto &i : array) { cout << i << ' '; } cout << '\n'; // Только для массивов // Можно запомнить, ведь меняются только названия переменных
// Выводит содержимое массива //Не нужно для char-массивов, можно сразу - cout << arr << endl;
```
```for (int i = 0; i != LENGTH; ++i) { sum += arr[i]; }``` - Вычисляем сумму всех значений массива
```swap();``` - функция, которая меняет местами 2 значения
```shell
Массивы в программированние - коллекции однотипных элементов
1, 0, 100, 25, 3 - пример коллекции натуральных чисел
Каждый элемент в массиве является переменной без имени
Во всех массивах все элементы начинаются с нулевого места(индекса)
Индекс массива всегда числовой и он предназначен для доступа к нужному элементу массива.
Массивы бывают фиксированные, динамические, "резиновые".
Фиксированные массивы в C++ всегда "знают" свой размер.
```
```int arr[];``` // [] - признак фиксированного массива // Объявили фиксированный массив размером 3
```int arrSize = sizeof(arr);``` - размер массива в байтах
```shell
arrSize = sizeof(arr) / sizeof(arr[0]); - кол-во элементов в массиве // плохо работает со символами // Классический способ
или
arrSize = sizeof(arr) / sizeof(*arr); // *arr - указатель на первый элемент в массиве // Через указатель
или
arrSize = *(&arr + 1) - arr; // &arr - ссылка ...
или
size_t LENGTH = std::size(arr) // через c++17
```
```shell
char map[10][10];
// Получить длину ряда многомерного массива
const int LENGTH = sizeof(map[0]) / sizeof(map[0][0]);
```
```cout << "Тип объекта " << typeid(arr).name() << endl;``` - возвращает тип объекта
```cout << *arr << endl;``` // Тоже самое arr[0] // arr[0] - 1-й элемент массива
```shell
Изменить длину фиксированного массива нельзя!
Задать длину массива можно константой или вручную
```
```int i_arr[getSize] {0};``` - Очень плохо! Т.к. заранее не известно какое будет число
```shell
char ch_arr[] {"Hello, World!"}; // Современный синтаксис объявления массивов!
char ch_arr[] = "Hello, World!";
const char *SUB_STRING = "Hello";
const auto SUB_STRING {"Hello"};
//Всё, что со словом auto - современный способ
```
```int array[2][3] {{7, -5, 9},{6, 4, 8}};``` - Двумерный массив
# РАНДОМ
```shell
int getRandomNum(int min, int max) {
    std::random_device rd; // std - гарантирует что эти имена не будут кофликтовать с именами, созданными программистом.
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> distrib(min, max); // Равномерное распределение целых чисел в диапазоне
    return distrib(gen);
}
```
```shell
random_shuffle(str.begin(), str.end()); // Немного устаревший вариант
shuffle(str.begin(), str.end(), gen1); // Современный вариант
```
# МЕТОДЫ
```shell
Метод find класса string возвращает позицию 1-го вхождения в строке
string::npos - сокращённо от no position, специальная константа
для обозначения несуществующего индекса в массиве
```
```cin.get(word, 100); // Метод для классических символьных массивов char```
``` .compare(...) - сравнивает строку перед методом со строкой в скобках```
``` .erase() - очищает СТРОКУ```
``` .empty() - проверяет пустая ли СТРОКА```
``` .find(...) - ищет индекс искомого символа/слова в СТРОКЕ```
``` .length = .size - ищут размер строки```
# АРХИВ
```npos``` - нет позиции
```string phrase {"I enjoy sport"};``` - Лучше так(прямая инициализация - дешевле для процессора)
```c = cin.get();``` - В отличие от cin читает все символы, даже пробел
```\r``` - этот символ перемещает курсор в начало текущей строки не переходя на новую строку.
```flush``` - чтобы сразу увидеть изменения
```shell
for (auto &i : str) { i = tolower(i); } // Ранжированный for, перебирает строку по индексам
```
```shell
int randNum(int, int) {
    static random_device rd; // static - гарантирует, что ф-ция будет объявлена 1 раз
    static mt19937 gen(rd());
    uniform_int_distribution<> dist(0, 8);
    return dist(gen);
}
```
```cin >> c; - cin >> Добавляет символ новой строки```
```c = cin.get(); - предпочтительней для char, считывает даже пробелы и служебные символы(Escape, Ctrl)```
```static_cast<> - нужен для преобразования из 1 типа в другой```
```pop_back(); - Удаляет последний элемент строки```
```back() - возвращает последний элемент строки```
```return -1; - >= 0 - успешное завершение работы(нужно для тестов)```
```bool hasLowerChar(const string& str) { // Рекомендуется всегда делать ссылку, она предотвращает копирование в другие ячейки память, можно ставить вплотную к переменной, без разницы```
```shell
inline string str(string s) { // inline - определяет функцию как встроенную, встроенная функция работает быстрее
    return s;
}
```
```cin.ignore(32767, 'n');``` - можно написать вместо ws
```shell
size_t - спец. тип данных, лучше использовать в циклах или при работе с массивами, размер которого совпадает с размером указателя
size_t - для обработки массивов, схож с long, всегда 8байт в x64 системе
size_t - перебирает каждый элемент массива, специально создан для массивов, безнаковый
```
```cout << *words << endl;``` - указатель на массив указывает на его 1 индекс
```con.at(4) = 'F';``` - С проверкой границ. Современный и безопасный метод. con - сумма строк(любое название может быть)
```shell
static std::mt19937 gen(rd()); // 32-битный генератор
```
```cout << "Случайное число " << fixed << setprecision(2) << d_secret << '\n';``` - setprecision - округляет число, dixed - фиксированное
```static``` - гарантирует, что генератор инициализируется только 1 ра при первом вызове функции
```Метод find``` - find метод, работает только с str, возвращает 1-ю позицию подстроки или символа в строке
```string::npos``` - спец. константа для обазначения несуществующего индекса массива
```string revCycle(string &str) { // & - для повыш. производительности(вместо копирования - ссылка)```
```static (например - int)``` - статичная переменная
```(char)abs``` - превращает переменную в тип данных который указан в скобках
```exit(0)``` - принудительное завершение программы
```+=``` - сложение с присваиванием
```%``` - деление по модулю(выводит остаток)
``` man.name ``` - оператор доступа к полю структуры
```shell
cin.ignore(37735, '\n'); // Очищает входной (cin >>) буфер
puts("Нажмите любую клавишу для завершения программы");
cin.get(); // Ожидает нажатия Enter и после приёма завершает программу
```
```shell
unsigned - по умолчанию int, но unsigned short - short, ... long - long
```
# ОПЕРАТОРЫ
```cin >> abs;``` - оператор который принимает с клавиатуры числа и символы
```getline(cin >> ...)``` - как cin но для строк
# ТЕКСТОВЫЙ РЕДАКТОР MICRO БИБЛИОТЕКА IOSTREAM
```cout.flush()``` - очистка выходного буфера
```cout << boolalpha;``` - слова true и false вместо 1 и 0
```((x == y) ? true : false)``` - Тернарный оператор
# IF,ELSE,WHILE И ДРУГОЕ
```else``` - тогда
```if``` - если
```flag``` - переменная содержащая true или false и использует
```while``` - цикл
```break``` - прыжок из цикла
# RAND
```int secretNum = 1 + (rand() % 10);``` - рандом который работает только если начальное число 0 или 1
```const double FRACTION = 1.0 / ((double)(RAND_MAX) + 1.0);```
```int min = 3, max = 100;``` - рандом с более сложной конструкцией
```int randNum = (int)(rand() * FRACTION * (max - min + 1) + min);```
```shell
текст
```
----------------------------------------------------------------------------------------------------------------
# Заголовог 1-го уровня
## Заголовок 2-го уровня
### Заголовок 3-го уровня
**Это выделенный текст (жирным шрифтом)**
*Это курсив(наклонный текст)*
***Это жирный наклонный текст***
Горизонтальная черта
---
___
***
~~Зачёркнутый текст~~
<u>Подчёркнутый текст</u>
> Какой-то важный текст
> Важный текст
>> Продолжение важного текста
>>> Продолжение продолжения важного текста
### Списки
#### Маркерный список
* Это 1-й элемент списка
* Это 2-й элемент списка
* Это 3-й элемент списка
***
+ Это 1-й элемент списка
+ Это 2-й элемент списка
+ Это 3-й элемент списка
    - 1-й подэлемент 3-го элемента списка
    - 2-й подэлемент 3-го элемента списка
    - 3-й подэлемент 3-го элемента списка
+ Это 4-й элемент списка
+ Это 5-й элемент списка
#### Цифровой список
1. Первый элемент списка
2. Второй элемент списка
3. Третий элемент списка
**Автоматический цифровой список**
1. Первый элемент списка
1. Второй элемент списка
1. Третий элемент списка
1. Новый элемент списка
1. Четвёртый элемент списка
1. Пятый элемент списка
### Список дел
- [x] Первое дело
- [ ] Второе дело
- [ ] Третье дело
**Список дел в виде ссылок**
- [ ] [1-я ссылка](#bar)
- [ ] [2-я ссылка](#qux)
- [ ] [3-я ссылка](#faz)
### Ссылки
<https://gitflic.ru/project/rurewa/cpp>\
[Надпись как ссылка](https://gitflic.ru/project/rurewa/cpp)
[Надпись как ссылка со всплывающей подсказой](https://gitflic.ru/project/rurewa/cpp "Это сайт курса")
### Картинка
![Какая-то картинка]()
### Таблица
| Название | Описание |
| ------| -------------- |
|Данные | Содержать информацию |
| Движок | на котором можно сделать игру |
| Расширение | это дополнение к движку|
### Код
```
#include <iostream>
using namespace std;
int main(){
    int x = -56;
    int y = 56;
    // Using noshowpos()
    cout << "showpos flag: " << showpos << x << endl;
    cout << "showpos flag: " << showpos << y << endl;
    return 0;
}
```
**Код с подсветкой**
```cpp
#includ <iostream>
using namespace std;
int main(){
    int x = -56;
    int y = 56;
    // Using noshowpos()
    cout << "showpos flag: " << showpos << x << endl;
    cout << "showpos flag: " << showpos << y << endl;
    return 0;
}
```
=======
# Заголовок первого уровня
## Заголовок второго уровня
### Заголовок третьего уровня
Это просто абзац. В этом репозитории будут мои учебные программы.
А в этом README будут заметки по программированию.
*Это курсив (наклонный текст)*
**Это выделенный текст (жирный текст)**
- Это 1-ый элемент списка
- Это 2-ой элемент списка
- Это 3-ий элемент списка
